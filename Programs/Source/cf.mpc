from recommender import *
from scipy.sparse.lil import lil_matrix
from math import sqrt
import sys
from Compiler.util import if_else


sys.setrecursionlimit(10000)

program.bit_length = 80
program.security = 40


# 0 no verbosity (secure)
# 1 compare final results
# 2 print dot-product and ratings
# 3 verbose dot-product calculation
DEBUG = 2

folder = "Prep-Data/ml-latest-small"


D = dataset(folder, discretize=1)
M = D.read(None,100)

n = D.n
m = D.m
rowcap = 2400

# n = 5
# m = 18
# rowcap = 12
# M = [[0 ,22, 68, 0 , 0 , 0 , 0 , 0 , 30, 20, 0 , 10, 22, 0 , 0 , 0 , 8 ,60],
#      [98,13, 0 , 0 , 50, 0 , 0 , 10, 0 , 25, 30, 0 , 90, 0 , 0 , 30, 0 , 0],
#      [60,0 , 34, 0 , 10, 20, 10, 0 , 80, 0 , 0 , 50, 0 , 29, 15, 90, 0 ,20],
#      [03,97,20 ,0  , 0 , 0 , 0 , 0 , 0 , 22, 80, 10, 25, 60, 0 , 40, 0 ,90],
#      [0 ,0 , 0 , 79, 45, 90, 20, 20, 80, 30, 50, 0 , 0 , 50, 60, 0 , 30, 0]]
# M = lil_matrix(M)

# Convert to secure input
print("Preparing rating input.")
print_ln("Starting rating input.")
clear_input_fp(0)


# Rating Matrix
values = M.toarray()
sM = SparseRowMatrix(n,m, rowcap)
for i in range(n):
    write_input_array(0, m, rowcap, values[i])
@for_range(n)
def loop_matrix(i):
    sMi = SparseArray.get_raw_input_from(0, m, rowcap, address=sM[i].address)
    sM[i].tailpointer = sMi.tailpointer

# for i in range(n):
#     for j in range(m):
#         print_str('%s ', sM[i][j].reveal())
#     print_ln(' ')
print("Finished preparing rating input.")
print_ln("Finished rating input.")

# Squared sums of user-vectors
M2 = M.power(2)
norms = []
for i in range(n):
    s = M2[i].sum()
    norms.append(s)
print(norms[72])
write_input_fp(0, *norms)  


norms = Array(n, sfix)
@for_range(n)
def loop_norms(i):
    res = sint.get_raw_input_from(0)
    res_f = sfix(); res_f.load_int(res)
    norms[i] = res_f
    

# for i in range(n):
#     print_str('%s ', norms[i].reveal())
# print_ln(' ')



    
    
# Cosine Similarity

def dot_unsafe(a, b):
    if a.capacity != b.capacity or a.length != b.length :
        raise CompileError("Size or Capacity does not match.")
    dot = MemValue(sint(0))
    l = a.length
    pa = MemValue(cint(0))
    pb = MemValue(cint(0))
    tpa = MemValue(a.tailpointer)
    tpb = MemValue(b.tailpointer)
    if DEBUG >= 3: 
        print_ln("tpa: %s, tpb: %s", tpa, tpb)
    @do_while
    def product_loop():
        ka = a.matrix[pa.read()][0]
        kb = b.matrix[pb.read()][0]
        if DEBUG >= 3: 
            print_ln("pa: %s, pb: %s", pa.read(), pb.read())
        cond = (ka == kb).reveal()
        if_then(cond)
        if DEBUG >= 3: 
            print_ln("case 1: ka %s kb %s", ka.reveal(), kb.reveal())
        dot.write(dot.read() + a.matrix[pa.read()][1] * b.matrix[pb.read()][1])
        pa.write(pa.read()+1)
        pb.write(pb.read()+1)
        end_if()
       
        
        #condition = ka < kb
        #pa.write(if_else(condition, val, res.read()))
        cond = (ka<kb).reveal()
        if_then(cond)
        if DEBUG >= 3: 
            print_ln("case 2: ka %s kb %s", ka.reveal(), kb.reveal())
        pa.write(pa.read()+1)
        end_if()
        
        cond = (ka > kb).reveal()
        if_then(cond)
        if DEBUG >= 3: 
            print_ln("case 3: ka %s kb %s", ka.reveal(), kb.reveal())
        pb.write(pb.read()+1)
        end_if()
        
        #abort = (ka == sint(0) and kb == sint(0)).reveal()
        cond = (pa.read() < tpa.read()) * (pb.read() < tpb.read())
        if DEBUG >= 3: 
            print_ln("dot: %s", dot.read().reveal())
            print_ln("Loop-Condition: %s < %s and %s < %s -> %s", pa.read(), tpa.read(), pb.read(), tpb.read(),  cond)
            print_ln(" ")
        return cond
    #@for_range(l)
    #def _(i):
    #    print_str('%s\r', i)
    #    dot.write(dot + a[i] * b[i])
    return dot.read()
    

def cosine_sim(a, norma, b, normb):
    dt = dot_unsafe(a,b)
    dot_f = sfix()
    dot_f.load_int(dt)
    if DEBUG >= 2:
        print_ln("dot: %s", dot_f.reveal())
    cos2 = (dot_f/norma)*(dot_f/normb) #square of cosine similarity: Take square root after revelation.
    if DEBUG >= 2:
        print_ln("cos2: %s", cos2.reveal())
        print_ln(" ")
    return cos2

# U2U Similarity Matrix


"""
sU2U = Matrix(n,n, sfix)
@for_range(n)
def sim_loop1(i):
    @for_range(n)
    def sim_loop2(j):
        U_i = sM[i]
        U_j = sM[j]
        sU2U[i][j] = cosine_sim(U_i, norms[i], U_j, norms[j])
    
print_ln('matrix of fixed points')
for i in range(n):
    for j in range(n):
        print_str('%s ', sU2U[i][j].reveal())
    print_ln(' ')
"""

i = 0
#n = 100
U_i = sM[i]
ratings = Array(n, sfix)

# DEBUG
if DEBUG >= 1:
    print("Computing Ratings unsecurely.")
    ratings_compare = Array(n, cfix)
    for j in range(n):
        sys.stdout.write("{} of {}\r".format(j,n))
        sys.stdout.flush()
        dot = sum( [M[i,l]*M[j,l] for l in range(m)] )
        if DEBUG >= 2:
            print( "{} of {}".format(j,n))
            print( "dot: {}".format(dot))
        cos2 = (float(dot) / M2[i].sum()) * (float(dot) / M2[j].sum())
        if DEBUG >= 2:
            print( "cos2: {}".format( cos2))
            print(" ")
        ratings_compare[j] = cfix(cos2)


# j=2
# U_j = sM[j]
# ratings[j] = cosine_sim(U_i, norms[i], U_j, norms[j])

print_ln("Computing Ratings securely.")
@for_range(n)
def ratings_loop(j):
    print_str("%s of %s\r",j, n )
    if DEBUG >= 2:
        print_ln("%s of %s\r",j, n )
    U_j = sM[j]
    ratings[j] = cosine_sim(U_i, norms[i], U_j, norms[j])
    if DEBUG >= 1:
        tol = cfix(0.0001)
        diff = ratings_compare[j]  - ratings[j].reveal() 
        if DEBUG >= 3:
            print_ln("%s", diff) 
        cond = (diff < tol) * (diff > -tol)
        if_then(cond)
        else_then()
        print_ln("Computation %s failed: %s != %s", j,  ratings[j].reveal(), ratings_compare[j])
        end_if()
    


