from recommender import *

# Python preprocessing for simulation of local computation.

folder = "Prep-Data/ml-latest-small"


D = dataset(folder, discretize=2)
M = D.read()

n = D.n
m = D.m

M2 = square_M(M,n,m)
Mb = bool_M(M,n,m)


print(M.shape)

undef = cint(0)

# Convert to secure input

sM = Matrix(n,m, sint)
for i in range(2):
    for j in range(m):
        sM[i][j] = sint(M[i,j])
        
sM2 = Matrix(n,m, sint)
for i in range(2):
    for j in range(m):
        sM[i][j] = sint(M2[i,j])
        
sMb = Matrix(n,m,sint)
for i in range(2):
    for j in range(m):
        sM[i][j] = sint(Mb[i,j])
        
# Secure Collaborative Filtering
 
def cosine_sim(a, a2, b, b2, intersec):
    dot = MemValue(sint(0))
    norma = MemValue(sint(0))
    normb = MemValue(sint(0))
    l = len(intersec)
    @for_range(l)
    def _(i):
        if_then(intersec[i])
        dot.write(dot + a[i] * b[i])
        norma.write(norma + a2[i])
        normb.write(normb + b2[i])
        end_if()
    
    dot_f = sfix(dot)
    norma_f = sfloat(norma)
    normb_f = sfloat(normb)
    r = dot_f**2 / (norma_f * normb_f)
    return r

 
def compute_intersection(a, b):
    n = len(a)
    intersection = Array(n, cint)
    @for_range(n)
    def _(i):
        intersection[i] = (a[i] * b[i]).reveal()
    return intersection
        
        
def sum(vec):
    res = sfloat(0)
    if isinstance(vec, sfloatArray):
        for i in range(vec.length) :
            res += vec[i]
    res = res.reveal()
    return res
    
intersec = compute_intersection(sMb[1], sMb[2])
r = cosine_sim(sM[1], sM2[1], sM[2], sM2[2], intersec )

print_ln("%s", r.reveal())

