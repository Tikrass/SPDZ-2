from recommender import *

# Python preprocessing for simulation of local computation.

folder = "Prep-Data/ml-latest-small"


D = dataset(folder, discretize=2)
M = D.read()

n = D.n
m = D.m
rowcap = 2400

M2 = square_M(M,n,m)
Mb = bool_M(M,n,m)

# Convert to secure input
clear_input_fp(0)

n = 100

sM = SparseRowMatrix(n,m, rowcap)
values = M.toarray()
for i in range(n):
    write_input_array(0, m, rowcap, values[i])
    U = SparseArray.get_raw_input_from(0, m, rowcap, address=sM[i].address)
    sM[i].tailpointer = U.tailpointer

sM2 = SparseRowMatrix(n,m, rowcap)
values = M2.toarray()
for i in range(n):
    write_input_array(0, m, rowcap, values[i])
    U = SparseArray.get_raw_input_from(0, m, rowcap, address=sM2[i].address)
    sM2[i].tailpointer = U.tailpointer

        
# Secure Collaborative Filtering
 
def cosine_sim(a, a2, b, b2, intersec):
    dot = MemValue(sint(0))
    norma = MemValue(sint(0))
    normb = MemValue(sint(0))
    l = len(intersec)
    @for_range(l)
    def _(i):
        if_then(intersec[i])
        dot.write(dot + a[i] * b[i])
        norma.write(norma + a2[i])
        normb.write(normb + b2[i])
        end_if()
    
    dot_f = sfix(dot)
    norma_f = sfloat(norma)
    normb_f = sfloat(normb)
    r = dot_f**2 / (norma_f * normb_f)
    return r

 
def compute_intersection(a, b):
    n = len(a)
    intersection = Array(n, cint)
    @for_range(n)
    def _(i):
        intersection[i] = (a[i] * b[i]).reveal()
    return intersection
        
        
def sum(vec):
    res = sfloat(0)
    if isinstance(vec, sfloatArray):
        for i in range(vec.length) :
            res += vec[i]
    res = res.reveal()
    return res
    
#intersec = compute_intersection(sMb[1], sMb[2])
#r = cosine_sim(sM[1], sM2[1], sM[2], sM2[2], intersec )

#print_ln("%s", r.reveal())

