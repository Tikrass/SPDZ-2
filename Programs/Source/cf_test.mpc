from collaborative_filter import SparseUBCosineCF, UBCosineCF, IBCosineCF
from recommender import *
import sys
from config_mine import *
from math import sqrt

# Program parameters
sys.setrecursionlimit(100000)

program.bit_length = 80
program.security = 40

# Verbosity
DEBUG = INTERMEDIATE

# IO Interface
IO = InputFp(0)

class Test():
    def __init__(self):
        self.n = 0
        self.m = 0
        self.rowcap = None

    # DATA
    def test_data(self):
        self.n = 5
        self.m = 18
        self.rowcap = 11
        self.M =[[0.0,2.2,6.8,0.0,0.0,0.0,0.0,0.0,3.0,2.0,0.0,1.0,2.2,0.0,0.0,0.0,0.8,6.0],
                 [9.8,1.3,0.0,0.0,5.0,0.0,0.0,1.0,0.0,2.5,3.0,0.0,9.0,0.0,0.0,3.0,0.0,0.0],
                 [6.0,0.0,3.4,0.0,1.0,2.0,1.0,0.0,8.0,0.0,0.0,5.0,0.0,2.9,1.5,9.0,0.0,2.0],
                 [0.3,9.7,2.0,0.0,0.0,0.0,0.0,0.0,0.0,2.2,8.0,1.0,2.5,6.0,0.0,4.0,0.0,9.0],
                 [0.0,0.0,0.0,7.9,4.5,9.0,2.0,2.0,8.0,3.0,5.0,0.0,0.0,5.0,6.0,0.0,3.0,0.0]]
        
        return self
    
    def small_data(self):
        self.n = 5
        self.m = 5
        self.rowcap = 5
        self.M =[[0.0,1.0,3.0,4.0,0.0],
                 [0.0,1.0,3.0,4.0,3.0],
                 [0.0,1.0,3.0,4.0,2.5],
                 [0.0,1.0,3.0,4.0,3.5],
                 [0.0,1.0,3.0,4.0,0.0]]
        
        return self

    def eval_data(self, n=None, m=None): 
        folder = "Prep-Data/ml-latest-small"
        
        D = dataset(folder)
        self.M = D.read(n,m).toarray()
        
        self.n = D.n
        self.m = D.m
        self.rowcap = 2400
        
        return self


class UBTest(Test):    
    
    def test(self, id, sparse):
        
        n = self.n
        m = self.m
        M = self.M
        
        if sparse:
            cap = self.rowcap
            CF = SparseUBCosineCF(n,m, self.rowcap)
        else:
            cap = None
            CF = UBCosineCF(n,m)
            
        print_ln("############################\nNEW TEST RUN")
        print_ln("User-based CF")
        print_ln("n = %s\nm = %s", n, m)
        if sparse:
            print_ln("sparse:\nrowcap = %s", self.rowcap)
        print_ln("")
            
        #########################
        # Preparing Private Input
        #########################
        print("Preparing rating input.")
        for i in range(n):
            sys.stdout.write(str(i)+'\r')
            IO.append_fp_array([int(j* (2**sfix.f)) for j in M[i]],capacity=cap)
            
        print("Preparing bitrating input.")
        for i in range(n):
            sys.stdout.write(str(i)+'\r')
            IO.append_fp_array(map(lambda x: 1 if x > 0 else 0, M[i]),capacity=cap)
            
            
        print("Preparing norm input.")
        # Squared sums of user-vectors
        for i in range(n):
            s = 0
            for j in range(m):
                s += M[i][j]**2
            s = sqrt(s)
            IO.append_fp(int(s * (2**sfix.f)))
                
    
        
        
        #########################
        # Reading Private Input
        #########################
        
        
        start_timer(id+1)
        if DEBUG >= VERBOSE:
            print_ln("Loading private input.")
        @for_range(n)
        def user_loop1(i):
            CF.load_ratings_from(i, 0)
            
        @for_range(n)
        def user_loop1(i):
            CF.load_bitratings_from(i, 0)

        @for_range(n)
        def user_loop2(i):
            CF.load_normalization_from(i, 0)
        stop_timer(id+1)
        
        
        
        #########################
        # Building Model
        #########################
        start_timer(id+2)
        CF.build_model()
        stop_timer(id+2)
        
        #########################
        # Output Model
        #########################
        if DEBUG >= VERBOSE_VALUES:
            print_ln("Model:")
            CF.print_model()
            
        #########################
        # Prediction
        #########################
        start_timer(id+3)
        if DEBUG >= VERBOSE_VALUES:
            print_ln("Prediction ALL:")
        @for_range(n)
        def user_loop(i):
            @for_range(m)
            def item_loop(j):
                if DEBUG == VERBOSE_PROGRESS:
                    print_str("\ruser %s item %s       ", i, j)
                prediction = CF.predict_rating(i,j).reveal()
                if DEBUG>=VERBOSE_VALUES:
                    print_str('%s ', prediction)
                    
            if DEBUG>=VERBOSE_VALUES:
                print_ln(' ')
        if DEBUG == VERBOSE_PROGRESS:
            print_str("\r")
        stop_timer(id+3)
        start_timer(id+4)
        
        if DEBUG >= VERBOSE_VALUES:
            print_ln("Prediction TRE:")
        @for_range(n)
        def user_loop(i):
            @for_range(m)
            def item_loop(j):
                if DEBUG == VERBOSE_PROGRESS:
                    print_str("\ruser %s item %s       ", i, j)
                prediction = CF.predict_rating_thresholded(i,j,cfix(0.3)).reveal()
                if DEBUG>=VERBOSE_VALUES:
                    print_str('%s ', prediction)
            if DEBUG>=VERBOSE_VALUES:
                print_ln(' ')
        if DEBUG == VERBOSE_PROGRESS:
            print_str("\r")
        stop_timer(id+4)
        #########################
        # Clean up memory
        #########################
        CF.delete()

class IBTest(Test):
    
    def test(self, id):
        n = self.n
        m = self.m
        M = self.M
        
        cap = None
        CF = IBCosineCF(n,m)
            
        print_ln("############################\nNEW TEST RUN")
        print_ln("Item-based CF")
        print_ln("n = %s\nm = %s", n, m)
        print_ln("")
            
        #########################
        # Preparing Private Input
        #########################
        print("Preparing rating input.")
        for i in range(n):
            sys.stdout.write(str(i)+'\r')
            IO.append_fp_array([int(j* (2**sfix.f)) for j in M[i]],capacity=cap)
            
        print("Preparing bitrating input.")
        for i in range(n):
            sys.stdout.write(str(i)+'\r')
            IO.append_fp_array(map(lambda x: 1 if x > 0 else 0, M[i]),capacity=cap)
            
        print("Preparing rating2 input.")
        for i in range(n):
            sys.stdout.write(str(i)+'\r')
            IO.append_fp_array([int((j**2) *  (2**sfix.f)) for j in M[i]],capacity=cap)
                
    
        
        
        #########################
        # Reading Private Input
        #########################
        
        
        start_timer(id+1)
        if DEBUG >= VERBOSE:
            print_ln("Loading private input.")
        @for_range(n)
        def user_loop1(i):
            CF.load_ratings_from(i, 0)
            
        @for_range(n)
        def user_loop1(i):
            CF.load_bitratings_from(i, 0)
            
        @for_range(n)
        def user_loop2(i):
            CF.load_ratings2_from(i, 0)
        stop_timer(id+1)
        
        #########################
        # Building Model
        #########################
        start_timer(id+2)
        #CF.calc_normalization_factors()
        CF.build_model()
        stop_timer(id+2)
        
        #########################
        # Output Model
        #########################
        if DEBUG >= VERBOSE_VALUES:
            print_ln("Model:")
            CF.print_model()
            
        #########################
        # Prediction
        #########################
        start_timer(id+3)
        if DEBUG >= VERBOSE_VALUES:
            print_ln("Prediction ALL:")
        @for_range(n)
        def user_loop(i):
            @for_range(m)
            def item_loop(j):
                if DEBUG == VERBOSE_PROGRESS:
                    print_str("\ruser %s item %s       ", i, j)
                prediction = CF.predict_rating(i,j).reveal()
                if DEBUG>=VERBOSE_VALUES:
                    print_str('%s ', prediction)
                    
            if DEBUG>=VERBOSE_VALUES:
                print_ln(' ')
        if DEBUG == VERBOSE_PROGRESS:
            print_str("\r")
        stop_timer(id+3)
        start_timer(id+4)
        
        if DEBUG >= VERBOSE_VALUES:
            print_ln("Prediction TRE:")
        @for_range(n)
        def user_loop(i):
            @for_range(m)
            def item_loop(j):
                if DEBUG == VERBOSE_PROGRESS:
                    print_str("\ruser %s item %s       ", i, j)
                prediction = CF.predict_rating_thresholded(i,j,cfix(0.5)).reveal()
                if DEBUG>=VERBOSE_VALUES:
                    print_str('%s ', prediction)
            if DEBUG>=VERBOSE_VALUES:
                print_ln(' ')
        if DEBUG == VERBOSE_PROGRESS:
            print_str("\r")
        stop_timer(id+4)
        #########################
        # Clean up memory
        #########################
        CF.delete()

T = UBTest().eval_data(100, m=5000) 
T.test(10, False)
T = UBTest().eval_data(200, m=5000) 
T.test(20, False)
T = UBTest().eval_data(300, m=5000) 
T.test(30, False)
T = UBTest().eval_data(400, m=5000) 
T.test(40, False)
T = UBTest().eval_data(500, m=5000) 
T.test(50, False)
#T.test(False, True)

# Write private input to file
IO.gen_input_fp()

        