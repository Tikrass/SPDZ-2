from collaborative_filter import SparseUBCosineCF, UBCosineCF, IBCosineCF
from recommender import *
import sys
from config_mine import *
from math import sqrt

# Program parameters
sys.setrecursionlimit(100000)

program.bit_length = 80
program.security = 40
sfix.set_precision(14, 28)
cfix.set_precision(14, 28)

# Verbosity
DEBUG = 3

# IO Interface
IO = InputFp(0)

class Test():
    def __init__(self):
        self.n = 0
        self.m = 0
        self.rowcap = None
    
    # DATA
    def small_data(self):
        self.n = 5
        self.m = 5
        self.rowcap = 5
        self.R =[[0.0,1.0,3.0,4.0,0.0],
                 [2.0,1.0,0.0,4.0,0.0],
                 [0.0,2.0,3.0,0.0,3.0],
                 [5.0,0.0,2.0,1.0,0.0],
                 [4.0,3.0,0.0,1.0,4.0]]
        self.B = [[0,1,1,1,0],
                   [1,1,0,1,0],
                   [0,1,1,0,1],
                   [1,0,1,1,0],
                   [1,1,0,1,1]]
        
        return self

    def eval_data(self, n=None, m=None): 
        folder = "Prep-Data/ml-latest-small"
        
        D = dataset(folder)
        self.R, self.B = D.read(n,m)
        self.n = D.n
        self.m = D.m
        self.rowcap = 2400
        
        return self
    
    def mean_centered(self):
        self.mean = [0 for _ in range(self.n)]
        for u in range(self.n):
            count = 0
            for i in range(self.m):
                self.mean[u] += self.R[u][i]
                count += self.B[u][i]
            self.mean[u] = self.mean[u]/count
            for i in range(self.m):
                if self.B[u][i] == 1:
                    self.R[u][i] = self.R[u][i] - self.mean[u]
        
        return self
    
    def testUBplain(self, id):
        
        n = self.n
        m = self.m
        R = self.R
        B = self.B
        
        CF = UBCosineCF(n,m)
            
        print_ln("############################\nNEW TEST RUN")
        print_ln("User-based CF")
        print_ln("n = %s\nm = %s", n, m)
        print_ln("")
            
        #########################
        # Preparing Private Input
        #########################
        print("Preparing rating input.")
        for u in range(n):
            sys.stdout.write(str(u)+'\r')
            IO.append_fp_array([int(r* (2**sfix.f)) for r in R[u]])
        
        print("Preparing rating2 input.")
        for u in range(n):
            sys.stdout.write(str(u)+'\r')
            IO.append_fp_array([int((r**2)* (2**sfix.f)) for r in R[u]])
            
        print("Preparing bitrating input.")
        for u in range(n):
            sys.stdout.write(str(u)+'\r')
            IO.append_fp_array(B[u])
    
        
        
        #########################
        # Reading Private Input
        #########################
        
        
        start_timer(id+1)
        if DEBUG >= VERBOSE:
            print_ln("Loading private input.")
        @for_range(n)
        def user_loop1(i):
            CF.load_ratings_from(i, 0)
            
        @for_range(n)
        def user_loop2(i):
            CF.load_ratings2_from(i, 0)

        @for_range(n)
        def user_loop3(i):
            CF.load_bitratings_from(i, 0)
        stop_timer(id+1)
        
        
        #########################
        # Building Model
        #########################
        start_timer(id+2)
        CF.build_model()
        stop_timer(id+2)
        
        #########################
        # Output Model
        #########################
        if DEBUG >= VERBOSE_VALUES:
            print_ln("Model:")
            CF.print_model()
            
        #########################
        # Prediction
        #########################
        start_timer(id+3)
        if DEBUG >= VERBOSE_VALUES:
            print_ln("Prediction ALL:")
        @for_range(n)
        def user_loop(i):
            @for_range(m)
            def item_loop(j):
                if DEBUG == VERBOSE_PROGRESS:
                    print_str("\ruser %s item %s       ", i, j)
                prediction = CF.predict_rating(i,j).reveal()
                if DEBUG>=VERBOSE_VALUES:
                    print_str('%s ', prediction)
                    
            if DEBUG>=VERBOSE_VALUES:
                print_ln(' ')
        if DEBUG == VERBOSE_PROGRESS:
            print_str("\r")
        stop_timer(id+3)
        
        #########################
        # Clean up memory
        #########################
        CF.delete()

    def testIB(self, id):
        n = self.n
        m = self.m
        R = self.R
        B = self.B
    
        CF = IBCosineCF(n,m)
            
        print_ln("############################\nNEW TEST RUN")
        print_ln("Item-based CF")
        print_ln("n = %s\nm = %s", n, m)
        print_ln("")
            
        #########################
        # Preparing Private Input
        #########################
        print("Preparing rating input.")
        for u in range(n):
            sys.stdout.write(str(u)+'\r')
            IO.append_fp_array([int(r* (2**sfix.f)) for r in R[u]])
            
        print("Preparing rating2 input.")
        for u in range(n):
            sys.stdout.write(str(u)+'\r')
            IO.append_fp_array([int((r**2) *  (2**sfix.f)) for r in R[u]])
            
        print("Preparing bitrating input.")
        for u in range(n):
            sys.stdout.write(str(u)+'\r')
            IO.append_fp_array(B[u])
                
    
        
        
        #########################
        # Reading Private Input
        #########################
        
        
        start_timer(id+1)
        if DEBUG >= VERBOSE:
            print_ln("Loading private input.")
        @for_range(n)
        def user_loop1(u):
            CF.load_ratings_from(u, 0)
            
        @for_range(n)
        def user_loop2(u):
            CF.load_ratings2_from(u, 0)
            
        @for_range(n)
        def user_loop3(u):
            CF.load_bitratings_from(u, 0)
        stop_timer(id+1)
            

        
        #########################
        # Building Model
        #########################
        start_timer(id+2)
        CF.build_model()
        stop_timer(id+2)
        
        #########################
        # Output Model
        #########################
        if DEBUG >= VERBOSE_VALUES:
            print_ln("Model:")
            CF.print_model()
            
        #########################
        # Prediction
        #########################
        start_timer(id+3)
        if DEBUG >= VERBOSE_VALUES:
            print_ln("Prediction :")
        for u in range(n):
            @for_range(m)
            def item_loop(i):
                if DEBUG == VERBOSE_PROGRESS:
                    print_str("\ruser %s item %s       ", u, i)
                prediction = CF.predict_rating(u,i)
                if self.mean:
                    prediction = self.mean[u] + prediction
                if DEBUG>=VERBOSE_VALUES:
                    print_str('%s ', prediction)
                    
            if DEBUG>=VERBOSE_VALUES:
                print_ln(' ')
        if DEBUG == VERBOSE_PROGRESS:
            print_str("\r")
        stop_timer(id+3)
        
        #########################
        # Clean up memory
        #########################
        CF.delete()
    
    def testUBsparse(self, id):
        
        n = self.n
        m = self.m
        R = self.R
        B = self.B
        cap = self.rowcap
        
        CF = SparseUBCosineCF(n,m)
            
        print_ln("############################\nNEW TEST RUN")
        print_ln("Sparse User-based CF")
        print_ln("n = %s\nm = %s, cap = %s", n, m, cap)
        print_ln("")
            
        #########################
        # Preparing Private Input
        #########################
        
        def append_fp_sparse_array(ratings,bitratings, capacity):
            input=[]
            tailpointer = 0
            for k in range(len(values)):
                if bitratings[k] != 0:
                    input += [k,ratings[k]*(2**sfix.f), (ratings[k]**2)* (2**sfix.f)]
                    tailpointer += 1;
            if tailpointer > capacity:
                raise CompileError("Tailpointer exceeds capacity: {} > {}!".format(tailpointer, capacity))
            for _ in range(tailpointer, capacity):
                input += [0,0,0]
            input += [tailpointer]
            self.input_fp +=  input
            
        print("Preparing sparse rating input.")
        for u in range(n):
            sys.stdout.write(str(u)+'\r')
            append_fp_sparse_array(R[u], B[u], cap)
        
    
        
        
        #########################
        # Reading Private Input
        #########################
        
        
        start_timer(id+1)
        if DEBUG >= VERBOSE:
            print_ln("Loading private input.")
        @for_range(n)
        def user_loop1(i):
            CF.load_ratings_from(i, 0)
        stop_timer(id+1)
        
        
        #########################
        # Building Model
        #########################
        start_timer(id+2)
        CF.build_model()
        stop_timer(id+2)
        
        #########################
        # Output Model
        #########################
        if DEBUG >= VERBOSE_VALUES:
            print_ln("Model:")
            CF.print_model()
            
        #########################
        # Prediction & mae
        #########################
        start_timer(id+3)
        if DEBUG >= VERBOSE_VALUES:
            print_ln("Prediction ALL:")
        @for_range(n)
        def user_loop(i):
            @for_range(m)
            def item_loop(j):
                if DEBUG == VERBOSE_PROGRESS:
                    print_str("\ruser %s item %s       ", i, j)
                prediction = CF.predict_rating(i,j).reveal()
                if DEBUG>=VERBOSE_VALUES:
                    print_str('%s ', prediction)
                    
            if DEBUG>=VERBOSE_VALUES:
                print_ln(' ')
        if DEBUG == VERBOSE_PROGRESS:
            print_str("\r")
        stop_timer(id+3)
        
        #########################
        # Clean up memory
        #########################
        CF.delete()
    

# T = Test().eval_data(50, m=5000).mean_centered()
# T.testIB(10)
# T = Test().eval_data(100, m=5000).mean_centered()
# T.testUBplain(20)
# T = Test().eval_data(150, m=5000).mean_centered()
# T.testUBplain(30)
# T = Test().eval_data(200, m=5000).mean_centered() 
# T.testUBplain(40)
# T = Test().eval_data(250, m=5000).mean_centered()
# T.testUBplain(50)

# T = Test().eval_data(150, m=4000).mean_centered()
# T.testIB(60)
# T = Test().eval_data(100, m=5000).mean_centered()
# T.testIB(70)
# T = Test().eval_data(150, m=6000).mean_centered()
# T.testIB(80)
# T = Test().eval_data(200, m=7000).mean_centered() 
# T.testIB(90)
# T = Test().eval_data(250, m=8000).mean_centered()
# T.testIB(100)

T = Test().small_data().mean_centered()
T.testUBplain(10)
T = Test().small_data().mean_centered()
T.testIB(20)

# Write private input to file
IO.gen_input_fp()

        