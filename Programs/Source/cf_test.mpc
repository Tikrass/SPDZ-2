from collaborative_filter import SparseUBCosineCF, UBCosineCF, IBCosineCF
from recommender import *
import sys
from config_mine import *
from math import sqrt, floor, ceil
import random

# Program parameters
sys.setrecursionlimit(100000)

program.bit_length = 80
program.security = 40
sfix.set_precision(14, 28)
cfix.set_precision(14, 28)

# Verbosity
DEBUG = 2

# IO Interface
IO = InputFp(0)

K = 10

NPREDICTIONS = 500

class Test():
    def __init__(self):
        self.n = 0
        self.m = 0
        self.rowcap = None
    
    # DATA
    def small_data(self):
        self.n = 5
        self.m = 5
        self.rowcap = 5
        self.R =[[0.0,1.0,3.0,4.0,0.0],
                 [2.0,1.0,0.0,4.0,0.0],
                 [0.0,2.0,3.0,0.0,3.0],
                 [5.0,0.0,2.0,1.0,0.0],
                 [4.0,3.0,0.0,1.0,4.0]]
        self.B = [[0,1,1,1,0],
                   [1,1,0,1,0],
                   [0,1,1,0,1],
                   [1,0,1,1,0],
                   [1,1,0,1,1]]
        
        return self
    
    def eval_data(self, n=None, m=None): 
        folder = "Prep-Data/ml-latest-small"
        
        D = dataset(folder)
        self.R, self.B = D.read(n,m)
        self.n = D.n
        self.m = D.m
        self.rowcap = 2400
        
        return self
    
    def mean_centered(self):
        self.mean = [0 for _ in range(self.n)]
        for u in range(self.n):
            count = 0
            for i in range(self.m):
                self.mean[u] += self.R[u][i]
                count += self.B[u][i]
            self.mean[u] = self.mean[u]/count
            for i in range(self.m):
                if self.B[u][i] == 1:
                    self.R[u][i] = self.R[u][i] - self.mean[u]
        
        return self
    
    def prep_private_input(self):
        #########################
        # Preparing Private Input
        #########################
        print("Preparing rating input.")
        for u in range(self.n):
            sys.stdout.write(str(u)+'\r')
            IO.append_fp_array([int(r* (2**sfix.f)) for r in self.R[u]])
        
        print("Preparing rating2 input.")
        for u in range(self.n):
            sys.stdout.write(str(u)+'\r')
            IO.append_fp_array([int((r**2)* (2**sfix.f)) for r in self.R[u]])
            
        print("Preparing bitrating input.")
        for u in range(self.n):
            sys.stdout.write(str(u)+'\r')
            IO.append_fp_array(self.B[u])
    
    def private_input(self, CF, id):
        #########################
        # Reading Private Input
        #########################
        
        start_timer(id+1)
        if DEBUG >= VERBOSE:
            print_ln("Loading private input.")
        @for_range(self.n)
        def user_loop1(i):
            CF.load_ratings_from(i, 0)
            
        @for_range(self.n)
        def user_loop2(i):
            CF.load_ratings2_from(i, 0)

        @for_range(self.n)
        def user_loop3(i):
            CF.load_bitratings_from(i, 0)
        stop_timer(id+1)
    
    def testUBplain(self, id, predict):
        
        n = self.n
        m = self.m
        R = self.R
        B = self.B
        CF = UBCosineCF(n,m)
            
        print_ln("############################\nNEW TEST RUN")
        print_ln("User-based CF")
        print_ln("n = %s\nm = %s", n, m)
        print_ln("")
            
        self.prep_private_input()
        self.private_input(CF, id)
        
        
        #########################
        # Building Model
        #########################
        start_timer(id+2)
        CF.build_model()
        stop_timer(id+2)
        
        #########################
        # Output Model
        #########################
        if DEBUG >= VERBOSE_VALUES:
            print_ln("Model:")
            CF.print_model()
            
        #########################
        # Prediction
        #########################
        if (predict):
            start_timer(id+3)
            if DEBUG >= VERBOSE_VALUES:
                print_ln("Prediction (MAE, RMSE):")
            
            mae = cfix(0)
            rmse = cfix(0)
            predictions = 0
            pperuser = int(floor(NPREDICTIONS/n))
            additionals = NPREDICTIONS - pperuser * n
            for u in range(n):
                Iu = [i for i in range(m) if B[u][i]==1]
                if u <= additionals:
                    sampsize = pperuser + 1
                else:
                    sampsize = pperuser
                sampling = random.sample(Iu, sampsize)
                for i in sampling:
                    if DEBUG == VERBOSE_PROGRESS:
                        print_str("\ruser %s item %s       ", u, i)
                    prediction = CF.predict_rating(u,i, K).reveal()
                    if self.mean:
                        prediction = self.mean[u] + prediction
                    error = prediction - R[u][i]
                    cint(error>=0) * (error + error) - error
                    mae += error
                    rmse += (error)**2
                    if DEBUG>=VERBOSE_VALUES:
                        print_str('%s ', prediction)
                if DEBUG>=VERBOSE_VALUES:
                    print_ln(' ')
            if DEBUG == VERBOSE_PROGRESS:
                print_str("\r")
            
            mae = mae / NPREDICTIONS
            rmse = (rmse / NPREDICTIONS).sqrt()
            print_ln("MAE: %s\nRMSE: %s", mae, rmse)
            stop_timer(id+3)
        
        #########################
        # Clean up memory
        #########################
        CF.delete()

    def testIB(self, id, predict):
        n = self.n
        m = self.m
        R = self.R
        B = self.B
    
        CF = IBCosineCF(n,m)
            
        print_ln("############################\nNEW TEST RUN")
        print_ln("Item-based CF")
        print_ln("n = %s\nm = %s", n, m)
        print_ln("")
            
        self.prep_private_input()
        self.private_input(CF,id)
            

        
        #########################
        # Building Model
        #########################
        start_timer(id+2)
        CF.build_model()
        stop_timer(id+2)
        
        #########################
        # Output Model
        #########################
        if DEBUG >= VERBOSE_VALUES:
            print_ln("Model:")
            CF.print_model()
            
        #########################
        # Prediction
        #########################
        if (predict):
            start_timer(id+3)
            if DEBUG >= VERBOSE_VALUES:
                print_ln("Prediction :")
            for u in range(n):
                @for_range(m)
                def item_loop(i):
                    if DEBUG == VERBOSE_PROGRESS:
                        print_str("\ruser %s item %s       ", u, i)
                    prediction = CF.predict_rating(u,i, K)
                    if self.mean:
                        prediction = self.mean[u] + prediction
                    if DEBUG>=VERBOSE_VALUES:
                        print_str('%s ', prediction)
                        
                if DEBUG>=VERBOSE_VALUES:
                    print_ln(' ')
            if DEBUG == VERBOSE_PROGRESS:
                print_str("\r")
            stop_timer(id+3)
        
        #########################
        # Clean up memory
        #########################
        CF.delete()
    
    def testUBsparse(self, id):
        
        n = self.n
        m = self.m
        R = self.R
        B = self.B
        cap = self.rowcap
        
        CF = SparseUBCosineCF(n,m)
            
        print_ln("############################\nNEW TEST RUN")
        print_ln("Sparse User-based CF")
        print_ln("n = %s\nm = %s, cap = %s", n, m, cap)
        print_ln("")
            
        #########################
        # Preparing Private Input
        #########################
        
        def append_fp_sparse_array(ratings,bitratings, capacity):
            input=[]
            tailpointer = 0
            for k in range(len(values)):
                if bitratings[k] != 0:
                    input += [k,ratings[k]*(2**sfix.f), (ratings[k]**2)* (2**sfix.f)]
                    tailpointer += 1;
            if tailpointer > capacity:
                raise CompileError("Tailpointer exceeds capacity: {} > {}!".format(tailpointer, capacity))
            for _ in range(tailpointer, capacity):
                input += [0,0,0]
            input += [tailpointer]
            self.input_fp +=  input
            
        print("Preparing sparse rating input.")
        for u in range(n):
            sys.stdout.write(str(u)+'\r')
            append_fp_sparse_array(R[u], B[u], cap)
        
    
        
        
        #########################
        # Reading Private Input
        #########################
        
        
        start_timer(id+1)
        if DEBUG >= VERBOSE:
            print_ln("Loading private input.")
        @for_range(n)
        def user_loop1(i):
            CF.load_ratings_from(i, 0)
        stop_timer(id+1)
        
        
        #########################
        # Building Model
        #########################
        start_timer(id+2)
        CF.build_model()
        stop_timer(id+2)
        
        #########################
        # Output Model
        #########################
        if DEBUG >= VERBOSE_VALUES:
            print_ln("Model:")
            CF.print_model()
            
        #########################
        # Prediction
        #########################
        start_timer(id+3)
        if DEBUG >= VERBOSE_VALUES:
            print_ln("Prediction ALL:")
        @for_range(n)
        def user_loop(i):
            @for_range(m)
            def item_loop(j):
                if DEBUG == VERBOSE_PROGRESS:
                    print_str("\ruser %s item %s       ", i, j)
                prediction = CF.predict_rating(i,j).reveal()
                if DEBUG>=VERBOSE_VALUES:
                    print_str('%s ', prediction)
                    
            if DEBUG>=VERBOSE_VALUES:
                print_ln(' ')
        if DEBUG == VERBOSE_PROGRESS:
            print_str("\r")
        stop_timer(id+3)
        
        #########################
        # Clean up memory
        #########################
        CF.delete()
    

T = Test().eval_data(100).mean_centered()
T.testUBplain(10, True)
T = Test().eval_data(200).mean_centered()
T.testUBplain(20, True)
T = Test().eval_data(300).mean_centered()
T.testUBplain(30, True)
T = Test().eval_data(400).mean_centered() 
T.testUBplain(40, True)
T = Test().eval_data(500).mean_centered()
T.testUBplain(50, True)

# T = Test().eval_data(100, m=2000).mean_centered()
# T.testIB(60, False)
# T = Test().eval_data(100, m=3000).mean_centered()
# T.testIB(70, False)
# T = Test().eval_data(100, m=4000).mean_centered()
# T.testIB(80, False)
# T = Test().eval_data(100, m=5000).mean_centered() 
# T.testIB(90, False)
# T = Test().eval_data(100, m=6000).mean_centered()
# T.testIB(100, False)

# T = Test().small_data().mean_centered()
# T.testUBplain(10, False)
# T = Test().small_data().mean_centered()
# T.testIB(20)

# Write private input to file
IO.gen_input_fp()

        