from collaborative_filter import SparseUBCosineCF, UBCosineCF, IBCosineCF
from recommender import *
import sys
from config_mine import *
from math import sqrt

# Program parameters
sys.setrecursionlimit(100000)

program.bit_length = 80
program.security = 40
sfix.set_precision(14, 28)
cfix.set_precision(14, 28)

# Verbosity
DEBUG = 2

# IO Interface
IO = InputFp(0)

class Test():
    def __init__(self):
        self.n = 0
        self.m = 0
        self.rowcap = None
    
    # DATA
    def small_data(self):
        self.n = 5
        self.m = 5
        self.rowcap = 5
        self.R =[[0.0,1.0,3.0,4.0,0.0],
                 [2.0,1.0,0.0,4.0,0.0],
                 [0.0,2.0,3.0,0.0,3.0],
                 [5.0,0.0,2.0,1.0,0.0],
                 [4.0,3.0,0.0,1.0,4.0]]
        self.B = [[0,1,1,1,0],
                   [1,1,0,1,0],
                   [0,1,1,0,1],
                   [1,0,1,1,0],
                   [1,1,0,1,1]]
        
        return self
    
    def eval_data(self, n=None, m=None): 
        folder = "Prep-Data/ml-latest-small"
        
        D = dataset(folder)
        self.R, self.B = D.read(n,m)
        self.n = D.n
        self.m = D.m
        self.rowcap = 2400
        
        return self
    
    def mean_centered(self):
        self.mean = [0 for _ in range(self.n)]
        for u in range(self.n):
            count = 0
            for i in range(self.m):
                self.mean[u] += self.R[u][i]
                count += self.B[u][i]
            self.mean[u] = self.mean[u]/count
            for i in range(self.m):
                if self.B[u][i] == 1:
                    self.R[u][i] = self.R[u][i] - self.mean[u]
        
        return self
    
    def prep_private_input(self):
        #########################
        # Preparing Private Input
        #########################
        print("Preparing rating input.")
        for u in range(self.n):
            sys.stdout.write(str(u)+'\r')
            IO.append_fp_array([int(r* (2**sfix.f)) for r in self.R[u]])
        
        print("Preparing rating2 input.")
        for u in range(self.n):
            sys.stdout.write(str(u)+'\r')
            IO.append_fp_array([int((r**2)* (2**sfix.f)) for r in self.R[u]])
            
        print("Preparing bitrating input.")
        for u in range(self.n):
            sys.stdout.write(str(u)+'\r')
            IO.append_fp_array(self.B[u])
    
    def private_input(self, CF, id):
        #########################
        # Reading Private Input
        #########################
        
        start_timer(id+1)
        if DEBUG >= VERBOSE:
            print_ln("Loading private input.")
        @for_range(self.n)
        def user_loop1(i):
            CF.load_ratings_from(i, 0)
            
        @for_range(self.n)
        def user_loop2(i):
            CF.load_ratings2_from(i, 0)

        @for_range(self.n)
        def user_loop3(i):
            CF.load_bitratings_from(i, 0)
        stop_timer(id+1)
    
    def testUBplain(self, id, predict):
        
        n = self.n
        m = self.m
        R = self.R
        B = self.B
        CF = UBCosineCF(n,m)
            
        print_ln("############################\nNEW TEST RUN")
        print_ln("User-based CF")
        print_ln("n = %s\nm = %s", n, m)
        print_ln("")
            
        self.prep_private_input()
        self.private_input(CF, id)
        
        
        #########################
        # Building Model
        #########################
        start_timer(id+2)
        CF.build_model()
        stop_timer(id+2)
        
        #########################
        # Output Model
        #########################
        if DEBUG >= VERBOSE_VALUES:
            print_ln("Model:")
            CF.print_model()
            
        #########################
        # Prediction
        #########################
        if (predict):
            start_timer(id+3)
            if DEBUG >= VERBOSE_VALUES:
                print_ln("Prediction ALL:")
            @for_range(n)
            def user_loop(i):
                @for_range(m)
                def item_loop(j):
                    if DEBUG == VERBOSE_PROGRESS:
                        print_str("\ruser %s item %s       ", i, j)
                    prediction = CF.predict_rating(i,j).reveal()
                    if DEBUG>=VERBOSE_VALUES:
                        print_str('%s ', prediction)
                        
                if DEBUG>=VERBOSE_VALUES:
                    print_ln(' ')
            if DEBUG == VERBOSE_PROGRESS:
                print_str("\r")
            stop_timer(id+3)
        
        #########################
        # Clean up memory
        #########################
        CF.delete()

    def testIB(self, id, predict):
        n = self.n
        m = self.m
        R = self.R
        B = self.B
    
        CF = IBCosineCF(n,m)
            
        print_ln("############################\nNEW TEST RUN")
        print_ln("Item-based CF")
        print_ln("n = %s\nm = %s", n, m)
        print_ln("")
            
        self.prep_private_input()
        self.private_input(CF,id)
            

        
        #########################
        # Building Model
        #########################
        start_timer(id+2)
        CF.build_model()
        stop_timer(id+2)
        
        #########################
        # Output Model
        #########################
        if DEBUG >= VERBOSE_VALUES:
            print_ln("Model:")
            CF.print_model()
            
        #########################
        # Prediction
        #########################
        if (predict):
            start_timer(id+3)
            if DEBUG >= VERBOSE_VALUES:
                print_ln("Prediction :")
            for u in range(n):
                @for_range(m)
                def item_loop(i):
                    if DEBUG == VERBOSE_PROGRESS:
                        print_str("\ruser %s item %s       ", u, i)
                    prediction = CF.predict_rating(u,i)
                    if self.mean:
                        prediction = self.mean[u] + prediction
                    if DEBUG>=VERBOSE_VALUES:
                        print_str('%s ', prediction)
                        
                if DEBUG>=VERBOSE_VALUES:
                    print_ln(' ')
            if DEBUG == VERBOSE_PROGRESS:
                print_str("\r")
            stop_timer(id+3)
        
        #########################
        # Clean up memory
        #########################
        CF.delete()
    
    

# T = Test().eval_data(50, m=5000).mean_centered()
# T.testUBplain(10, False)
# T = Test().eval_data(100, m=5000).mean_centered()
# T.testUBplain(20, False)
# T = Test().eval_data(150, m=5000).mean_centered()
# T.testUBplain(30, False)
# T = Test().eval_data(200, m=5000).mean_centered() 
# T.testUBplain(40, False)
# T = Test().eval_data(250, m=5000).mean_centered()
# T.testUBplain(50, False)

T = Test().eval_data(100, m=2000).mean_centered()
T.testIB(60, False)
T = Test().eval_data(100, m=3000).mean_centered()
T.testIB(70, False)
T = Test().eval_data(100, m=4000).mean_centered()
T.testIB(80, False)
T = Test().eval_data(100, m=5000).mean_centered() 
T.testIB(90, False)
T = Test().eval_data(100, m=6000).mean_centered()
T.testIB(100, False)

# T = Test().small_data().mean_centered()
# T.testUBplain(10)
# T = Test().small_data().mean_centered()
# T.testIB(20)

# Write private input to file
IO.gen_input_fp()

        